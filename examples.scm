(load "load.scm")
;; regression
(define (train)
  (letrec* ((test-module (module:join! (module-fc 2 10) (module-activation 10 make-relu-neuron) (module-fc 10 1)))
	    (data '(((1 0) 1) ((0 0) 0) ((0 1) 1) ((1 1) 0)))
	    (expected (make-neuron-controllable))
	    (loss-module (loss:mse test-module (list (cadr expected))))
	    (opt (make-adam-optimizer 0.001 loss-module))
	    (loop (lambda (i)
		    (if (< i 100000)
			(let* ((sample (list-ref data (random (length data))))
			       (x (car sample))
			       (y (cadr sample)))
			  (module:reset! loss-module)
			  ((car expected) y)
			  (module:forward loss-module x)
			  (if (= (remainder i 1000) 0) (begin ;;(pp (list 'output (module:forward test-module x)))
							      ;;(pp (list 'expected y))
							      ;;(pp (list 'weights (map param:get-weight (module:get-params loss-module))))
							      (pp (list 'loss i (module:forward loss-module x)))))
			  (module:backward! loss-module (list -1))
					;(pp (list "grads" (module:get-param-grads loss-module)))
			  ;;(pp "")
			  (opt)
			  (loop (+ i 1)))))))

    (loop 0)))
(train)

;; classification
(load "load.scm")
(define dd (load-mnist "mnist_test_1000.csv"))
(define (train)
  (letrec* ((test-module (module:join! (module-fc 784 10) (module-activation 10 make-relu-neuron) (module-fc 10 10)))
	    (data dd)
	    (expected (map (lambda x (make-neuron-controllable)) (iota 10)))
	    (loss-module (loss:cross-entropy test-module (map cadr expected)))
	    (opt (make-adam-optimizer 0.001 loss-module))
	    (loop (lambda (i)
		    (if (< i 10000)
			(let* ((sample (list-ref data (random (length data))))
			       (x (map (lambda (p) (/ p 255)) (car sample)))
			       (y (cadr sample)))
			  (module:reset! loss-module)
			  ;; set one-hot vector to expected class
			  (map (lambda (n) ((car n) 0)) expected)
			  ((car (list-ref expected y)) 1)
			  (module:forward loss-module x)
			  (if (= (remainder i 1) 0) (begin (pp (list 'output (module:forward test-module x)))
							     (pp (list 'expected y))
							     ;;(pp (list 'weights (map param:get-weight (module:get-params loss-module))))
							     (pp (list 'loss (module:forward loss-module x)))))
			  (module:backward! loss-module (list -1))
			  (opt)
			  (loop (+ i 1)))
			  test-module))))
    (loop 0)))

(define (test-mnist module)
  (letrec* (
    (data (load-mnist "mnist_test.csv"))
	(expected (map (lambda x (make-neuron-controllable)) (iota 10)))
    (loss-module (loss:cross-entropy test-module (map cadr expected)))
    (loop (lambda (i corr)
		    (if (< i 1000)
			(let* ((sample (list-ref data (random (length data))))
			       (x (map (lambda (p) (/ p 255)) (car sample)))
			       (y (cadr sample)))
			  (module:reset! loss-module)
			  (map (lambda (n) ((car n) 0)) expected)
			  ((car (list-ref expected y)) 1)
			  (module:forward loss-module x)
			  (begin (pp (list 'predicted (max-idx (module:forward test-module x))))
							      (pp (list 'expected y))
							      ;;(pp (list 'weights (map param:get-weight (module:get-params loss-module))))
							      (pp (list 'loss i (module:forward loss-module x))))
					;(pp (list "grads" (module:get-param-grads loss-module)))
			  ;;(pp "")
			  (loop (+ i 1) (if (eqv? (max-idx (module:forward test-module x)) y)  (+ corr 1) corr )))
            test-module)
            corr)))

    (loop 0)))
(train)
